"""
@author: ieva-balta, majocava, naaattella
"""

library(dplyr)
library(ggplot2)
library(readr)
library(jsonlite)
library(tidyr)

"""
This script takes the information from the files that contain the merged accession codes from the unique accessions found only in dbPTM/CPLM database
the PTM features and calculates the distribution of the unique accessions based on whether they have experimental ECO codes, predicted ECO-codes, and 
whether they cna be retrieved from UniProtKB. 

It requires three files:
 1. PTM_old_organism.csv: Generated by running the 0.dataframe_building.py script. Contains a summary of all the accession codes in dbPTM/CPLM database from Zenodo (version 1.4)
 2. protein_existence_summary_isoforms_merged.csv: Generated by running the 2. df_comparison_unique_accession.py script. Contains a summary of the existence levels, and the new merged accessions codes
 3. ptms_dbptm.csv: Generated by running the 2. df_comparison_unique_accession.py script. It contains ptm information of the unique accession codes of dbPTM/CPLM that were not merged.
"""

# Set the directory as needed
setwd("C:/Users/majoc/Downloads/OneDrive_1_11-8-2025/comparison")

light_blue <- "#E4A788"
light_red <- "#5361B1"
light_green <- "#5E93BF"
light_orange <- "#9D2C2E"

palette <- c("Collapsed Accessions" = "#E4A788", 
             "PTMs: ECO-validated" = "#9D2C2E", 
             "PTMs: Predicted" = "#5E93BF", 
             "PTMs: Non-existent" = "#5361B1")

# Read the unique accession codes. Change the path if needed
existence_df <- read_csv("protein_existence_summary_isoforms_merged.csv")
old_ptm <- read_csv("PTM_old_organism.csv")

# Total accessions
total_accessions <- unique(existence_df$Accession)
cat("Total number of accessions is:", length(total_accessions), "\n")  # We get 216,667. This checks out

# Set of accession codes
old_accessions <- unique(old_ptm$UniProt_Accession)

# Filter by existence levels
non_exist <- existence_df %>% filter(Existence == "Not found")
exist_1 <- existence_df %>% filter(Existence == "1: Evidence at protein level")
exist_2 <- existence_df %>% filter(Existence == "2: Evidence at transcript level")
exist_3 <- existence_df %>% filter(Existence == "3: Inferred from homology")
exist_4 <- existence_df %>% filter(Existence == "4: Predicted")
exist_5 <- existence_df %>% filter(Existence == "5: Uncertain")
exist_unknown <- existence_df %>% filter(Existence == "Unknown")

# Unique accessions per level
unique_non_exist <- unique(non_exist$Accession)
unique_exist_1 <- unique(exist_1$Accession)
unique_exist_2 <- unique(exist_2$Accession)
unique_exist_3 <- unique(exist_3$Accession)
unique_exist_4 <- unique(exist_4$Accession)
unique_exist_5 <- unique(exist_5$Accession)
unique_exist_unknown <- unique(exist_unknown$Accession)

cat("Level 1:", length(unique_exist_1), "\n")
cat("Level 2:", length(unique_exist_2), "\n")
cat("Level 3:", length(unique_exist_3), "\n")
cat("Level 4:", length(unique_exist_4), "\n")
cat("Level 5:", length(unique_exist_5), "\n")
cat("Unknown:", length(unique_exist_unknown), "\n")
cat("Not found:", length(unique_non_exist), "\n")

total_unique <- length(unique_exist_1) + length(unique_exist_2) + length(unique_exist_3) +
  length(unique_exist_4) + length(unique_exist_5) + length(unique_exist_unknown) +
  length(unique_non_exist)
cat(total_unique, "\n")

# Bar plot
levels <- c('Level 1', 'Level 2', 'Level 3', 'Level 4', 'Level 5', 'Unknown', 'Not found')
counts <- c(length(unique_exist_1), length(unique_exist_2), length(unique_exist_3),
            length(unique_exist_4), length(unique_exist_5), length(unique_exist_unknown),
            length(unique_non_exist))

plot_data <- data.frame(Level = levels, Count = counts)

ggplot(plot_data, aes(x = Level, y = Count)) +
  geom_bar(stat = "identity") +
  ylab('Count') +
  ggtitle('Number of Proteins based on their existence levels') +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggsave("final_unique_proteins_presentation.png")

# Merged proteins
merged_proteins_df <- existence_df %>%
  filter(!is.na(MergedTo) & MergedTo != Accession)

count_merged <- length(unique(merged_proteins_df$Accession))
cat("Total Unique Merged/Retired Accessions:", count_merged, "\n")

# Group for unique MergedTo and multiplicities
merged_grouped <- merged_proteins_df %>%
  group_by(MergedTo) %>%
  summarise(OldAccessionCount = n(),
            Existence = first(Existence)) %>%
  arrange(desc(OldAccessionCount))

# Existence Levels for All Old Merged/Retired Accessions
old_exist_dist <- merged_grouped %>%
  group_by(Existence) %>%
  summarise(Count = sum(OldAccessionCount)) %>%
  arrange(desc(Count))

cat("\nExistence Levels for All Unique Old Merged/Retired Accessions (", sum(old_exist_dist$Count), " total):\n")
for (i in 1:nrow(old_exist_dist)) {
  cat(old_exist_dist$Existence[i], ":", old_exist_dist$Count[i], "\n")
}
cat("Total:", sum(old_exist_dist$Count), "\n")

# Optional: Check for any old accessions without an existence level
missing_exist <- merged_proteins_df %>% filter(is.na(Existence))
cat("Old accessions missing existence level:", nrow(missing_exist), "\n")

# Summary stats for merged
unique_merged_to <- nrow(merged_grouped)
many_to_one_count <- sum(merged_grouped$OldAccessionCount > 1)
cat("Unique MergedTo accessions:", unique_merged_to, "\n")
cat("Number of MergedTo with multiple old accessions:", many_to_one_count, "\n")

# Retrieved (InLocalDB True) among merged
merged_proteins_df <- merged_proteins_df %>%
  mutate(InLocalDB = MergedTo %in% old_accessions)

retrieved_merged <- merged_proteins_df %>% filter(InLocalDB)
unique_retrieved_merged <- unique(retrieved_merged$MergedTo)
cat("Unique MergedTo accessions retrieved in local DB:", length(unique_retrieved_merged), "\n")

# Existence levels for unique MergedTo
exist_levels_merged <- merged_grouped %>%
  group_by(Existence) %>%
  summarise(Count = n())

exist_1_merged <- exist_levels_merged %>% filter(Existence == "1: Evidence at protein level") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_2_merged <- exist_levels_merged %>% filter(Existence == "2: Evidence at transcript level") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_3_merged <- exist_levels_merged %>% filter(Existence == "3: Inferred from homology") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_4_merged <- exist_levels_merged %>% filter(Existence == "4: Predicted") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_5_merged <- exist_levels_merged %>% filter(Existence == "5: Uncertain") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_unknown_merged <- exist_levels_merged %>% filter(Existence == "Unknown") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_notfound_merged <- exist_levels_merged %>% filter(Existence == "Not found") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}

cat("\nExistence Levels for Unique MergedTo Accessions:\n")
cat("Level 1:", exist_1_merged, "\n")
cat("Level 2:", exist_2_merged, "\n")
cat("Level 3:", exist_3_merged, "\n")
cat("Level 4:", exist_4_merged, "\n")
cat("Level 5:", exist_5_merged, "\n")
cat("Unknown:", exist_unknown_merged, "\n")
cat("Not Found:", exist_notfound_merged, "\n")

# For retrieved merged, group similarly
retrieved_grouped <- retrieved_merged %>%
  group_by(MergedTo) %>%
  summarise(Existence = first(Existence))

exist_levels_retrieved <- retrieved_grouped %>%
  group_by(Existence) %>%
  summarise(Count = n())

exist_1_retrieved <- exist_levels_retrieved %>% filter(Existence == "1: Evidence at protein level") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_2_retrieved <- exist_levels_retrieved %>% filter(Existence == "2: Evidence at transcript level") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_3_retrieved <- exist_levels_retrieved %>% filter(Existence == "3: Inferred from homology") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_4_retrieved <- exist_levels_retrieved %>% filter(Existence == "4: Predicted") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_5_retrieved <- exist_levels_retrieved %>% filter(Existence == "5: Uncertain") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_unknown_retrieved <- exist_levels_retrieved %>% filter(Existence == "Unknown") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}
exist_notfound_retrieved <- exist_levels_retrieved %>% filter(Existence == "Not found") %>% pull(Count) %>% {ifelse(length(.) == 0, 0, .)}

cat("\nExistence Levels for Unique Retrieved MergedTo Accessions:\n")
cat("Level 1:", exist_1_retrieved, "\n")
cat("Level 2:", exist_2_retrieved, "\n")
cat("Level 3:", exist_3_retrieved, "\n")
cat("Level 4:", exist_4_retrieved, "\n")
cat("Level 5:", exist_5_retrieved, "\n")
cat("Unknown:", exist_unknown_retrieved, "\n")
cat("Not Found:", exist_notfound_retrieved, "\n")

# PTM features
ptm_features <- read_csv("ptms_dbptm.csv")

# Map the existence levels to PTM features
ptm_features <- ptm_features %>%
  left_join(existence_df %>% select(Accession, Existence), by = "Accession")

cat("Number of retrieved accession codes", length(unique(ptm_features$Accession)), "\n")

ptm_types <- c("Modified residue", "Modified residue (large scale data)", "Lipidation", "Glycosylation", "Disulfide bond", "Cross-link")
experimental_eco <- c('ECO:0000269', 'ECO:0000314', 'ECO:0007744', 'ECO:0007829')

# Parse ECO code
parse_eco <- function(x) {
  if (is.na(x) || x == "[]" || x == "") {
    return(character(0))
  }
  tryCatch({
    items <- fromJSON(x)
    sapply(items, function(item) item$evidenceCode %||% "")
  }, error = function(e) {
    character(0)
  })
}

ptm_features$ECO_codes <- lapply(ptm_features$ECO, parse_eco)

# Classify Accessions
accession_classes <- list()

grouped <- ptm_features %>% group_by(Accession)
grouped_list = group_split(grouped)

for (i in seq_along(grouped_list)) {
  subset <- grouped_list[[i]]
  acc <- subset$Accession[1]
  
  # Class 1: accession has "No feature" or FeatureType missing
  feature_types <- subset$FeatureType
  feature_types[is.na(feature_types)] <- "No Feature"
  if (all(!feature_types %in% ptm_types)) {
    accession_classes[[acc]] <- "No PTM features"
    next
  }
  
  # Filter ptm rows
  ptm_rows <- subset %>% filter(FeatureType %in% ptm_types)
  
  # Class 1: No PTM rows after filtering.
  if (nrow(ptm_rows) == 0) {
    accession_classes[[acc]] <- "No PTM features"
    next
  }
  
  # Get the ECO codes in PTM rows
  all_codes <- unique(unlist(ptm_rows$ECO_codes))
  
  # Class 2: Experiment, yes or no?
  if (any(all_codes %in% experimental_eco)) {
    accession_classes[[acc]] <- "Experimental PTM"
  } else {
    accession_classes[[acc]] <- "Predicted PTM only"
  }
}

# Put results into a dataframe
result <- data.frame(
  Accession = names(accession_classes),
  PTM_Class = unlist(accession_classes)
)

result <- result %>%
  left_join(existence_df %>% select(Accession, Existence), by = "Accession")

# Summary
summary <- result %>%
  count(PTM_Class)

cat("\n=== PTM Classification Summary ===\n")
print(summary)

summary_by_level <- result %>%
  group_by(Existence, PTM_Class) %>%
  summarise(Count = n(), .groups = 'drop')

cat("\n=== PTM Classification Summary by Existence Level ===\n")
print(summary_by_level)

missing <- result %>%
  filter(is.na(Existence) & PTM_Class == "Experimental PTM")

cat("Experimental PTM accessions missing from existence_df:", nrow(missing), "\n")
print(head(missing))

write_csv(result, "ptm_classification_experiment.csv")

# New stacked bar graph as requested
# x-axis: levels, stacked by PTM_Class

plot_data_ptm <- summary_by_level %>%
  mutate(Level = case_when(
    Existence == "1: Evidence at protein level" ~ "Level 1",
    Existence == "2: Evidence at transcript level" ~ "Level 2",
    Existence == "3: Inferred from homology" ~ "Level 3",
    Existence == "4: Predicted" ~ "Level 4",
    Existence == "5: Uncertain" ~ "Level 5",
    Existence == "Unknown" ~ "Unknown",
    Existence == "Not found" ~ "Not found",
    TRUE ~ NA_character_
  )) %>%
  filter(!is.na(Level)) %>%
  select(Level, PTM_Class, Count)


# Percentage of merged that were retrieved
overall_retrieved_percent <- (length(unique_retrieved_merged) / unique_merged_to) * 100
cat("Overall percentage of merged accessions retrieved:", overall_retrieved_percent, "%\n")

# Per level
merged_counts_df <- data.frame(
  Level = existence_levels,
  Merged = merged_counts,
  Retrieved = retrieved_counts
)

merged_counts_df <- merged_counts_df %>%
  mutate(Percent_Retrieved = ifelse(Merged > 0, (Retrieved / Merged) * 100, 0))

print(merged_counts_df)

###################################################################
########################### Stack Plot ############################
###################################################################

# Define data
levels <- c("Level 1", "Level 2", "Level 3", "Level 4", "Level 5", "Unknown")
merged_old <- c(9535, 664, 633, 443, 29, 4)
no_ptms <- c(38427, 28366, 63790, 52861, 396, 4539)
predicted <- c(7629, 5195, 3592, 398, 79, 0)
experimental <- c(0, 5, 2, 0, 6, 0)
percentage <- c(89.49, 52.16, 10.90, 8.82, 94.44, 25)

palette <- c("Collapsed Accessions" = "#E4A788", 
             "PTMs: ECO-validated" = "#9D2C2E", 
             "PTMs: Predicted" = "#5E93BF", 
             "PTMs: Non-existent" = "#5361B1")

# Create stacked data frame
data <- data.frame(
  Level = rep(levels, 4),
  Category = rep(c("PTMs: Non-existent", "PTMs: Predicted", "PTMs: ECO-validated", "Collapsed Accessions"), each = length(levels)),
  Count = c(no_ptms, predicted, experimental, merged_old)
)

# Define Category factor with desired stacking order
data$Category <- factor(data$Category, levels = c("Collapsed Accessions", "PTMs: ECO-validated", "PTMs: Predicted", "PTMs: Non-existent"))

# Then plot as before

stack_plot = ggplot(data, aes(x = Level, y = Count, fill = Category)) +
  geom_bar(stat = "identity") +
  ylab("Number of Accessions (log-scale)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 1),
        axis.text.y = element_text(size = 14),
        legend.position = c(0.90, 0.90),
        legend.title = NULL,
        panel.grid = element_blank(),
        axis.line = element_line(color = "black"),
        panel.background = element_rect(fill = "white", color = NA),
        plot.background = element_rect(fill = "white", color = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm")) +
  scale_fill_manual(values = palette) +
  scale_y_log10(expand = c(0, 0), labels = function(x) log10(x)) +
  scale_x_discrete()

ggsave("stacked_bar.svg", plot = stack_plot, device = "svg", width = 10, height = 6)

